<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Archinime</title>
  <link rel="icon" href="Logo_Archinime.avif" type="image/png">
  <link rel="preload" as="image" href="videoframe.jpg">

  <style>
    /* ---------------------------
       Variables globales y reset
       --------------------------- */
    :root {
      --header-approx-height: 72px;
      --global-extra-gap: -6px; 
    }

    *{margin:0;padding:0;box-sizing:border-box;}
    html,body{height:100%;overflow-x:hidden; overflow-y:auto; font-family:sans-serif; color:#fff; -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;}

    /* Fondo */
    #bg-video{position:fixed; top:0; left:0; width:100%; height:100%; object-fit:cover; z-index:-2; opacity:0;
    transition:opacity .6s ease; background:#000; pointer-events:none;}
    #overlay{position:fixed; top:0; left:0; width:100%; height:100%; z-index:-1;
    background: url('galaxia-morado1.avif') center/cover no-repeat, linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.6)); opacity:1; transition:opacity .6s ease;
    pointer-events:none;}

    /* Header */
    header{
      position:sticky; top:0; padding:1rem 2rem;
      display:flex; align-items:center; gap:1rem; 
      background:rgba(0,0,0,0.7); backdrop-filter:blur(5px); 
      z-index:40; transition:background .3s; flex-wrap:wrap;
      min-height: var(--header-approx-height);
      /* Modificaci√≥n: Usamos justify-content space-between pero con trucos para centrar */
      justify-content: space-between;
    }

    /* T√≠tulo y logo */
    header h1{
      cursor:default;
      display:flex; align-items:center; justify-content: center; /* Centrar contenido interno */
      gap:.6rem; font-size:1.8rem; font-weight:900;
      white-space:nowrap; flex: 1; /* Ocupa el espacio disponible para empujar */
      animation: hueShift 8s linear infinite;
      background: linear-gradient(90deg,
        #00fff7 0%,
        #7afcff 12%,
        #9bff6a 24%,
        #ffd700 36%,
        #ff6ad5 48%,
        #ff4d4d 60%,
        #ff9f40 72%,
        #8b5cf6 84%,
        #00d4ff 100%);
      background-size: 250% 250%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 1px 18px rgba(0,0,0,0.5);
      /* Para asegurar centrado visual en PC, a veces se usa posici√≥n absoluta si los controles estorban,
         pero flex:1 con text-align center suele bastar si los lados est√°n equilibrados. 
         Aqu√≠ forzamos que el H1 ocupe el centro visualmente. */
       text-align: center;
    }
    
    /* Contenedor vac√≠o para equilibrar el header en PC si fuera necesario, 
       pero por ahora usaremos margin-auto en los controles */

    @keyframes hueShift {
      0% { background-position: 0% 50%; transform: translateY(0); }
      25% { background-position: 50% 100%; transform: translateY(-1px); }
      50% { background-position: 100% 50%; transform: translateY(0); }
      75% { background-position: 50% 0%; transform: translateY(1px); }
      100% { background-position: 0% 50%; transform: translateY(0); }
    }
    
    /* ESTILOS DEL LOGO CLICABLE */
    header h1 img#logo { 
        width:42px;
        height:42px; object-fit:contain; border-radius:6px; display:block; 
        cursor:pointer;
        transition: transform 0.2s;
    }
    header h1 img#logo:hover { transform: scale(1.1); }
    header h1 img#logo:active { transform: scale(0.95); }

    /* Social inline */
    .social-inline { display:flex; align-items:center; gap:.5rem; margin-left:.4rem; flex:0 0 auto; }
    .social-inline button {
      width:44px; height:44px; border-radius:50%; border:none; padding:0; display:inline-flex;
      align-items:center; justify-content:center;
      cursor:pointer; background:rgba(255,255,255,0.95);
      color:#000; box-shadow:0 6px 18px rgba(0,0,0,0.28); overflow:hidden;
    }
    .social-inline img { width:70%; height:70%; object-fit:cover; display:block; border-radius:50%; image-rendering:auto; }

    /* Controles (selects + search) */
    .controls { 
      display:flex; align-items:center; gap:0.6rem; 
      /* margin-left:auto empuja los controles a la derecha */
      margin-left:auto; 
      flex-wrap:wrap; 
      flex: 0 0 auto; /* No crecer */
    }
    .controls select, .controls input {
      padding:.5rem .9rem;
      border:none; border-radius:8px; font-size:1rem;
      background:rgba(255,255,255,0.95);
      color:#000; min-width:150px; -webkit-appearance:none; appearance:none;
      box-sizing:border-box;
    }
    #search { width:220px; min-width:120px; }

    /* Layout principal */
    .container{ max-width:1200px; margin: calc(var(--header-approx-height) + var(--global-extra-gap)) auto 1.5rem;
    padding:0 1.6rem; z-index:6; position:relative; transition: margin-top .12s ease, padding-top .12s ease;
    }
    main.container { padding-top: calc(var(--header-approx-height) + var(--global-extra-gap)); }

    .grid{ display:grid; grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); gap:1.2rem; margin-top:0.3rem; }
    .card{ border-radius:10px; overflow:hidden; position:relative; cursor:pointer; transition:all .2s ease; opacity:1; transform:translateY(0); will-change: transform; }
    .card img{ width:100%; display:block; transition:transform .4s,filter .4s; will-change: transform; }
    .card:hover img{ transform:scale(1.05); filter:brightness(75%); }
    .info{ position:absolute; bottom:0; left:0; right:0; background:rgba(0,0,0,0.7); padding:.75rem; transform:translateY(100%); transition:transform .3s; }
    .card:hover .info{ transform:translateY(0); }

    /* Foreground container */
    #fgContainer { position:fixed;
    z-index:8; pointer-events:auto; display:flex; align-items:center; justify-content:center;
    right:20px; bottom:20px; overflow:hidden; min-width:120px; min-height:80px; max-width:360px; max-height:640px; background:transparent; border-radius:10px;
    }
    @media (max-width:420px){ #fgContainer { right:12px; bottom:12px; max-width:220px; max-height:360px; } }
    #fgContainer canvas#fgCanvas, #fgContainer video#fgVideo{ width:100%; height:100%; display:block; pointer-events:none; object-fit:contain; border-radius:8px; }

    /* Decorations */
    #decorations { position:fixed; inset:0; pointer-events:none; z-index:36; }
    .shooting-star { position:fixed; z-index:36; pointer-events:none; width: 18px; height: 18px; opacity: 0; transform: translate(-50%, -50%) rotate(12deg);
    filter: drop-shadow(0 6px 18px rgba(255,255,210,0.08)); }
    .shooting-tail { position:absolute; left:0; top:50%; width: 160px; height: 4px; transform-origin:left center;
    opacity:0.95; pointer-events:none; filter: blur(1px); }

    /* Popups m√≥vil */
    .mobile-select-popup { position: absolute; z-index:1200;
    background: rgba(2,2,6,0.98); border:1px solid rgba(255,255,255,0.06); border-radius:8px; box-shadow:0 20px 60px rgba(0,0,0,0.6); 
    /* Forzamos tama√±os fijos para evitar que crezcan raramente */
    max-height: 220px; min-width: 140px; width: auto; 
    overflow:auto; padding:0.2rem; font-size:0.92rem; -webkit-overflow-scrolling:touch;
    }
    .mobile-select-popup .opt { padding: .26rem .5rem; border-radius:6px; margin:.06rem 0; font-size:0.92rem; line-height:1.05; cursor:pointer; color:#eaeaea; }
    .mobile-select-popup .opt[aria-selected="true"], .mobile-select-popup .opt.selected { font-weight:700; background: rgba(255,255,255,0.03); }
    .mobile-select-popup .opt:hover { background: rgba(255,255,255,0.04); }

    @media (max-width:780px) {
      .mobile-select-popup { max-height: 160px; min-width: 120px; font-size:0.9rem; }
    }
    @media (max-width:420px) {
      .mobile-select-popup { max-height: 120px; min-width: 110px; font-size:0.85rem; padding:0.12rem; }
      .mobile-select-popup .opt { padding: .18rem .32rem; font-size:0.82rem; }
    }

    /* Adaptaci√≥n m√≥vil */
    @media (max-width:780px) {
      header { 
        padding:0.45rem 0.6rem;
        gap:0.4rem; align-items:center; flex-wrap: wrap; 
        justify-content: center; /* Centrado general */
      } 
      
      /* En m√≥vil el t√≠tulo va arriba y centrado */
      header h1 { 
        order: 1;
        width: 100%; 
        justify-content: center; /* Fuerza a "Archinime" a estar al medio */
        margin-bottom: 5px;
        flex: 0 0 100%;
      }
      
      .controls { 
        order: 2; 
        width: 100%; 
        margin-left: 0; 
        margin-top: 0;
        justify-content: center;
      }

      .controls {
        display:grid;
        grid-template-columns: repeat(2, 1fr);
        gap:0.4rem;
        align-items:center;
      }
      .controls select, .controls input { font-size:0.9rem; padding:.28rem .48rem; border-radius:8px; min-width:0; }
      #search { width:100%; min-width:0; }
      .social-inline button { width:34px; height:34px; padding:0; }
      .social-inline img { width:66%; height:66%; }

      .container { margin-top: 0 !important; padding-top: 0 !important; }
      main.container { padding-top: 0 !important; }
      .grid { margin-top: 0 !important; gap:0.6rem !important; }
    }

    @media (max-width:420px) {
      header { padding:0.38rem 0.5rem; }
      .controls { grid-template-columns: repeat(2, 1fr); gap:.28rem; }
      .controls select, .controls input { font-size:0.82rem; padding:.22rem .36rem; border-radius:6px; }
      .social-inline button { width:32px; height:32px; }
      .social-inline img { width:66%; height:66%; }
      
      .container { margin-top: 0 !important; padding-top: 0 !important; }
      main.container { padding-top: 0 !important; }
      .grid { margin-top: 0 !important; gap:0.5rem !important; grid-template-columns: repeat(3, 1fr); }
    }

    @media (max-width:767px) {
      .container { padding: 0 1rem; }
      .grid { grid-template-columns: repeat(3, 1fr); gap:0.9rem; }
      .card { min-height: 0; }
      .card img { height: auto; }
    }

    .no-results { grid-column:1 / -1; padding:2.6rem; border-radius:14px; display:flex; gap:1.25rem; align-items:center; justify-content:center; flex-direction:column;
    background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(0,0,0,0.3)); border:1px solid rgba(255,255,255,0.04); box-shadow:0 18px 60px rgba(0,0,0,0.6); text-align:center; transition: transform .28s cubic-bezier(.2,9,2,1), box-shadow .2s; }
    
    .play-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:9; pointer-events:auto; display:none; }
    .play-btn{ background: rgba(0,0,0,0.7); color:#fff; border:2px solid #fff; padding:14px 22px; border-radius:12px; font-size:18px; cursor:pointer; }
  </style>
</head>
<body>

  <video id="bg-video" poster="galaxia-morado1.avif" autoplay muted loop playsinline preload="metadata">
    <source src="galaxia.mp4" type="video/mp4">
    Tu navegador no soporta v√≠deo.
  </video>
  <div id="overlay" aria-hidden="true"></div>

  <audio id="bg-music" autoplay></audio>

  <header>
    <h1>
      <img id="logo" src="Logo_Archinime.avif" alt="Logo Archinime" onclick="openInNewTab('https://archinime.github.io/-Archinime-/Archinime%20CMS%20-%20Creador.html')" title="Ir al Creador CMS">
      
      <span>Archinime</span>
      
      <span class="social-inline" id="social-inline" title="S√≠guenos">
        <button id="youtube-btn" type="button" aria-label="Abrir YouTube en nueva pesta√±a" onclick="(function(e){ e.stopPropagation(); openInNewTab('https://www.youtube.com/@Archinime-k2g'); })(event)">
          <img src="youtube.avif" alt="YouTube">
        </button>
        <button id="tiktok-btn" type="button" aria-label="Abrir TikTok en nueva pesta√±a" onclick="(function(e){ e.stopPropagation(); openInNewTab('https://www.tiktok.com/@archinime?_t=ZS-8zGoKE4IqLw&_r=1'); })(event)">
          <img src="tiktok.avif" alt="TikTok">
        </button>
      </span>
    </h1>

    <div class="controls" id="controls">
      <select id="genre-select" onchange="filtro()" aria-label="Seleccionar g√©nero">
        <option value="">Todos los g√©neros</option>
        <option>Acci√≥n</option>
        <option>Animaci√≥n</option>
        <option>Aventura</option>
        <option>Ciencia ficci√≥n</option>
        <option>Cocina</option>
        <option>Comedia</option>
        <option>Comedia oscura</option>
        <option>Cosplay</option>
        <option>Cyberpunk</option>
        <option>Deducci√≥n Social</option>
        <option>Deportivo</option>
        <option>Dibujo Animado</option>
        <option>Divulgaci√≥n Cient√≠fica</option>
        <option>Drama</option>
        <option>Ecchi</option>
        <option>Espionaje</option>
        <option>Escolar</option>
        <option>Fantas√≠a</option>
        <option>Fantas√≠a oscura</option>
        <option>Familiar</option>
        <option>Gag</option>
        <option>Gore</option>
        <option>Harem</option>
        <option>Hentai</option>
        <option>Hist√≥rico</option>
        <option>Horror</option>
        <option>Incesto</option>
        <option>Infantil</option>
        <option>Isekai</option>
        <option>Isekai Inverso</option>
        <option>Kaiju</option>
        <option>Mah≈ç Sh≈çjo</option>
        <option>Mecha</option>
        <option>Militar</option>
        <option>Mitolog√≠a</option>
        <option>Misterio</option>
        <option>Musical</option>
        <option>Nekketsu</option>
        <option>Parodia</option>
        <option>Policial</option>
        <option>Post-apocal√≠ptico</option>
        <option>Psicol√≥gico</option>
        <option>Reverse Harem</option>
        <option>Road Movie</option>
        <option>Romance</option>
        <option>RPG</option>
        <option>Slice of Life</option>
        <option>Sobrenatural</option>
        <option>Steampunk</option>
        <option>Superh√©roes</option>
        <option>Survival</option>
        <option>Survival Game</option>
        <option>Suspenso</option>
        <option>Tent√°culos</option>
        <option>Terror</option>
        <option>Terror psicol√≥gico</option>
        <option>Thriller</option>
        <option>Thriller psicol√≥gico</option>
        <option>Tokusatsu</option>
        <option>Tragedia</option>
        <option>Yaoi</option>
        <option>Yuri</option>
      </select>

      <select id="demographic-select" onchange="filtro()" aria-label="Seleccionar demograf√≠a">
        <option value="">Todas las demograf√≠as</option>
        <option>Gekiga</option>
        <option>Josei</option>
        <option>Kodomo</option>
        <option>Seijin</option>
        <option>Seinen</option>
        <option>Sh≈çjo</option>
        <option>Sh≈çnen</option>
      </select>

      <select id="rating-select" onchange="filtro()" aria-label="Seleccionar valoraci√≥n">
        <option value="">‚≠ê Todas</option>
        <option value="excellent">‚≠ê Excelente (4.8‚Äì5.0)</option>
        <option value="good">‚≠ê Buena (4.6‚Äì4.7)</option>
        <option value="regular">‚≠ê Regular (&lt;4.5)</option>
      </select>

      <input id="search" placeholder="üîç Buscar anime‚Ä¶" oninput="debouncedFiltro()" aria-label="Buscar anime">
    </div>

  </header>

  <main class="container">
    <div class="grid" id="grid"></div>
  </main>

  <div class="stage" aria-hidden="true">
    <div id="fgContainer" aria-label="V√≠deo frontal">
      <canvas id="fgCanvas"></canvas>
      <video id="fgVideo" muted loop playsinline></video>
    </div>

    <div class="play-overlay" id="playOverlay" style="display:none;">
      <button class="play-btn" id="playBtn">Pulsar para iniciar</button>
    </div>
  </div>

  <div id="decorations" aria-hidden="true">
    <svg id="star-template" class="shooting-star decor-hidden-mobile" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="display:none;" aria-hidden="true">
      <g>
        <circle cx="4" cy="4" r="4" fill="#fff9e0" opacity="0.98"></circle>
        <rect class="shooting-tail" x="8" y="3" width="160" height="4"></rect>
      </g>
    </svg>
  </div>

  <script src="index-data.js"></script>
  <script src="fondo-musica-data.js"></script> <script src="animaciones-data.js"></script>   <script>
    /* ----------------------------
       Renderizado grid
       ---------------------------- */
    function render(list) {
      const grid = document.getElementById('grid');
      if (!list || list.length === 0) {
        grid.innerHTML = `
          <div class="no-results" role="status" aria-live="polite">
            <div class="title shimmer">¬°Ups! No se encontraron resultados que coincidan con la b√∫squeda.</div>
            <div class="subtitle">¬øNo lo encuentras? Puede que lo hayas escrito con un error o que todav√≠a no lo haya subido.</div>
            <div class="sparkles"><button class="btn-reset" id="btn-reset">Entiendo</button></div>
          </div>
        `;
        const btn = document.getElementById('btn-reset');
        if (btn) btn.addEventListener('click', () => {
          document.getElementById('search').value = '';
          document.getElementById('genre-select').value = '';
          if(document.getElementById('demographic-select')) document.getElementById('demographic-select').value = '';
          document.getElementById('rating-select').value = '';
          filtro();
          document.getElementById('search').focus();
        });
        return;
      }

      grid.innerHTML = list.map(a => `
        <div class="card" onclick="location='anime-detail.html?id=${a.id}'" role="link" tabindex="0">
          <img src="${a.img}" alt="${a.title}">
          <div class="info"><strong>${a.title}</strong><span>‚≠ê ${a.rating ? (a.rating.toFixed? a.rating.toFixed(1): a.rating) : '‚Äî'}</span></div>
        </div>
      `).join('');
    }

    function updateResultsCount(count){ const el = document.getElementById('results-count'); if (el) el.textContent = count; }
    
    function debounce(fn, wait){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }
    
    const debouncedFiltro = debounce(filtro, 200);

    function normalizeText(s){
      try { return (s||'').toLowerCase().normalize('NFD').replace(/\p{M}/gu, ''); } 
      catch(e) { return (s||'').toLowerCase().replace(/[\u0300-\u036f]/g, ''); }
    }

    function getBestTitleForSort(a){ const titles = [a.title].concat(a.aliases || []); const norm = titles.map(t=>normalizeText(t)); norm.sort(); return norm[0]; }

    function filtro(){
      const qRaw = document.getElementById('search').value || '';
      const q = qRaw.trim(); const qn = normalizeText(q);
      const g = document.getElementById('genre-select').value;
      const d = document.getElementById('demographic-select') ? document.getElementById('demographic-select').value : '';
      const cat = document.getElementById('rating-select').value;

      const filtrados = animes.filter(a=>{
        const titles = [a.title].concat(a.aliases || []);
        const matchesText = !qn || titles.some(t => normalizeText(t).startsWith(qn));
        const byGenre = !g || (a.genres && a.genres.includes(g));
        const byDemo  = !d || (a.genres && a.genres.includes(d));
        let byRating = true;
        if (cat==='excellent') byRating = a.rating >= 4.8;
        else if (cat==='good') byRating = a.rating >= 4.6 && a.rating < 4.8;
        else if (cat==='regular') byRating = a.rating < 4.6;
        return matchesText && byGenre && byDemo && byRating;
      });

      let resultList = filtrados.slice();
      if (qn) {
        resultList.sort((A,B)=>{
          const titlesA = [A.title].concat(A.aliases||[]).map(t=>normalizeText(t));
          const titlesB = [B.title].concat(B.aliases||[]).map(t=>normalizeText(t));
          const aStarts = titlesA.some(t=>t.startsWith(qn));
          const bStarts = titlesB.some(t=>t.startsWith(qn));
          if (aStarts !== bStarts) return aStarts ? -1 : 1;
          const na = getBestTitleForSort(A);
          const nb = getBestTitleForSort(B);
          return na < nb ? -1 : na > nb ? 1 : 0;
        });
      } else {
        resultList.sort((A,B)=> normalizeText(A.title) < normalizeText(B.title) ? -1 : normalizeText(A.title) > normalizeText(B.title) ? 1 : 0);
      }
      render(resultList);
      updateResultsCount(resultList.length);
    }

    function shuffleArray(arr){ const a = arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    
    if (typeof animes !== 'undefined') {
        render(shuffleArray(animes));
        updateResultsCount(animes.length);
    } else {
        console.error("Error: No se encontr√≥ la lista 'animes'. Revisa que index-data.js est√© bien vinculado.");
    }

    document.getElementById('search').addEventListener('input', debouncedFiltro);
    document.getElementById('search').addEventListener('keydown', (e)=>{ if(e.key === 'Enter'){ e.preventDefault(); filtro(); } });
    ['genre-select','rating-select','demographic-select'].forEach(id=>{ const el=document.getElementById(id); if(el) el.addEventListener('change', filtro); });

    function getPerformanceHints() {
      let cores = navigator.hardwareConcurrency || 4;
      let deviceMem = navigator.deviceMemory || 4;
      let prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      let processingScale = 1.0;
      if (cores >= 8 && deviceMem >= 8) processingScale = 1.0;
      else if (cores >= 4 && deviceMem >= 4) processingScale = 0.85;
      else if (cores >= 2 && deviceMem >= 2) processingScale = 0.6;
      else processingScale = 0.45;
      if (prefersReducedMotion) processingScale = Math.min(processingScale, 0.55);
      return { cores, deviceMem, processingScale, prefersReducedMotion };
    }

    window.addEventListener('DOMContentLoaded', () => {
      const video = document.getElementById('bg-video');
      const overlay = document.getElementById('overlay');
      const hints = getPerformanceHints();

      if (hints.processingScale < 0.55 || hints.prefersReducedMotion) {
        try { video.pause(); video.style.display = 'none'; overlay.style.opacity = '1'; } catch(e){}
      } else {
        try { video.preload = video.getAttribute('preload') || 'metadata'; } catch(e){ console.warn(e); }
        video.muted = true; video.playsInline = true;
        const revealVideo = () => { video.style.opacity = '1'; overlay.style.opacity = '0'; };
        overlay.addEventListener('transitionend', (ev) => { if (ev.propertyName === 'opacity' && getComputedStyle(overlay).opacity === '0') overlay.style.display = 'none'; });
        video.addEventListener('playing', () => { revealVideo(); }, { once: true });
        video.addEventListener('canplaythrough', () => { video.play().catch(()=>{}); }, { once: true });
        video.addEventListener('loadeddata', () => { video.play().catch(()=>{}); }, { once: true });
      }
    });

    /* ----------------------------
       L√ìGICA DE M√öSICA (MODIFICADA)
       ---------------------------- */
    window.addEventListener('DOMContentLoaded', () => {
      const audio = document.getElementById('bg-music');
      const hints = getPerformanceHints();
      
      // Usamos la lista importada de fondo-musica-data.js
      // Si no existe por alg√∫n error, fallback array vac√≠o
      const musicList = (typeof globalMusicList !== 'undefined') ? globalMusicList : [];
      
      if (musicList.length === 0) return;

      // Empezar aleatoriamente
      let currentMusicIndex = Math.floor(Math.random() * musicList.length);

      function playByIndex(idx) {
         // Ajuste √≠ndice c√≠clico
         currentMusicIndex = ((idx % musicList.length) + musicList.length) % musicList.length;
         
         audio.src = musicList[currentMusicIndex];
         audio.load();
         audio.volume = 0.75;
         if (hints.processingScale >= 0.6) {
           audio.play().catch(()=> { document.addEventListener('click', ()=>{ audio.play().catch(()=>{}); }, { once: true }); });
         }
      }

      // Al terminar, siguiente canci√≥n en orden (bucle secuencial)
      audio.addEventListener('ended', ()=> { 
          currentMusicIndex = (currentMusicIndex + 1) % musicList.length; 
          playByIndex(currentMusicIndex); 
      });

      playByIndex(currentMusicIndex);
    });

    function openInNewTab(url){ try{ const w = window.open(url, '_blank'); if (w) w.focus(); }catch(e){} }

    /* ----------------------------
       Chroma + FG logic
       ---------------------------- */
    const fgContainer = document.getElementById('fgContainer');
    const fgCanvas = document.getElementById('fgCanvas');
    const fgVideo = document.getElementById('fgVideo');
    const bgVideo = document.getElementById('bg-video');
    const bgMusic = document.getElementById('bg-music');
    const ctx = fgCanvas.getContext ? fgCanvas.getContext('2d', { alpha: true }) : null;

    let off = document.createElement('canvas');
    let offCtx = off.getContext ? off.getContext('2d') : null;
    let chromaIntervalId = null;
    let chromaFps = 24;
    let usingChroma = true;
    let visibilityPaused = false;
    let currentVideoObj = null;
    let lastObjectUrl = null;
    let isAnimatingExplosion = false;
    let scheduledTimer = null;
    
    // Usamos la lista importada de animaciones-data.js
    const videoList = (typeof globalVideoList !== 'undefined') ? globalVideoList : [];

    function pickRandomVideo(excludeId){
      if (!videoList || videoList.length === 0) return null;
      if (videoList.length === 1) return videoList[0];
      const candidates = videoList.filter(v => v.id !== excludeId);
      if (candidates.length === 0) return videoList[Math.floor(Math.random()*videoList.length)];
      return candidates[Math.floor(Math.random()*candidates.length)];
    }

    function placeRandomSide(infoObj){
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const margin = window.matchMedia('(max-width:767px)').matches ? '12px' : '20px';
      if (side === 'left') { fgContainer.style.left = margin; fgContainer.style.right = ''; }
      else { fgContainer.style.right = margin; fgContainer.style.left = ''; }
    }

    function drawProcessedToScreen(){
      if (!ctx || !fgCanvas) return;
      const cw = fgCanvas.clientWidth || parseInt(fgCanvas.style.width) || fgCanvas.width;
      const ch = fgCanvas.clientHeight || parseInt(fgCanvas.style.height) || fgCanvas.height;
      const vw = off.width || 1;
      const vh = off.height || 1;
      ctx.clearRect(0, 0, cw, ch);
      if (vw === 0 || vh === 0 || cw === 0 || ch === 0) return;
      const scale = Math.min(cw / vw, ch / vh);
      const dw = Math.round(vw * scale);
      const dh = Math.round(vh * scale);
      const dx = Math.round((cw - dw) / 2);
      const dy = Math.round((ch - dh) / 2);
      ctx.drawImage(off, 0, 0, vw, vh, dx, dy, dw, dh);
    }

    function adjustContainerToVideo(video, infoObj){
      const vw = video.videoWidth || 16;
      const vh = video.videoHeight || 9;
      const hints = getPerformanceHints();
      let maxW = Math.min(window.innerWidth * 0.32, 360);
      let maxH = Math.min(window.innerHeight * 0.4, 640);
      if (window.matchMedia('(max-width:767px)').matches) {
        if (infoObj && infoObj.id === 'rem') {
          maxW = Math.min(window.innerWidth * 0.30, 180);
          maxH = Math.min(window.innerHeight * 0.30, 200);
        } else if (infoObj && infoObj.id === 'hola') {
          maxW = Math.min(window.innerWidth * 0.62, 380);
          maxH = Math.min(window.innerHeight * 0.62, 520);
        } else {
          maxW = Math.min(window.innerWidth * 0.45, 260);
          maxH = Math.min(window.innerHeight * 0.45, 420);
        }
      } else {
        maxW = Math.min(window.innerWidth * 0.32, 360);
        maxH = Math.min(window.innerHeight * 0.4, 640);
      }

      const displayScale = Math.min(maxW / vw, maxH / vh, 1.0);
      const displayW = Math.max(120, Math.round(vw * displayScale));
      const displayH = Math.max(80, Math.round(vh * displayScale));
      fgContainer.style.width = displayW + 'px';
      fgContainer.style.height = displayH + 'px';

      const dpr = Math.max(1, window.devicePixelRatio || 1);
      fgCanvas.width = Math.round(displayW * dpr);
      fgCanvas.height = Math.round(displayH * dpr);
      fgCanvas.style.width = displayW + 'px';
      fgCanvas.style.height = displayH + 'px';
      if (ctx && typeof ctx.setTransform === 'function') {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      const capHigh = 1280;
      const capMed = 720;
      const hintsScale = hints.processingScale;
      const chosenCap = hintsScale >= 0.85 ? capHigh : hintsScale >= 0.6 ? capMed : 480;

      const sourceW = vw;
      const sourceH = vh;
      const sourceRatio = sourceW / sourceH || (16/9);

      let offW = Math.min(sourceW, chosenCap);
      let offH = Math.round(offW / sourceRatio);
      if (offH > chosenCap) {
        offH = chosenCap;
        offW = Math.round(offH * sourceRatio);
      }
      off.width = Math.max(16, offW);
      off.height = Math.max(16, offH);

      resizeFireCanvas();
    }

    function applyChromaKey(imageData, settings, keyColor = 'green'){
      const data = imageData.data;
      const len = data.length;
      const thresh = settings.threshold ?? 0.4; const minDiff = settings.diff ?? 30;
      const soften = settings.soft ?? 30;
      for (let i = 0; i < len; i += 4) {
        const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
        if (a === 0) continue;
        const sum = r + g + b + 1;
        if (keyColor === 'blue') {
          const maxrg = Math.max(r, g);
          const blueScore = (b - maxrg) / sum;
          const isBlueCandidate = (b - maxrg) > minDiff && blueScore > (thresh - 0.2);
          if (!isBlueCandidate) { data[i+3] = 255; continue; }
          const diff = b - maxrg;
          if (soften <= 0) data[i+3] = (diff > minDiff) ? 0 : 255;
          else {
            const t = (diff - minDiff) / soften;
            const clamped = Math.max(0, Math.min(1, t));
            data[i+3] = Math.round((1 - clamped) * 255);
          }
        } else {
          const maxrb = Math.max(r, b);
          const greenScore = (g - maxrb) / sum;
          const isGreenCandidate = (g - maxrb) > minDiff && greenScore > (thresh - 0.2);
          if (!isGreenCandidate) { data[i+3] = 255; continue; }
          const diff = g - maxrb;
          if (soften <= 0) data[i+3] = (diff > minDiff) ? 0 : 255;
          else {
            const t = (diff - minDiff) / soften;
            const clamped = Math.max(0, Math.min(1, t));
            data[i+3] = Math.round((1 - clamped) * 255);
          }
        }
      }
      return imageData;
    }

    function processFrame(video, infoObj){
      if (!usingChroma || visibilityPaused) return;
      if (video.paused || video.ended) return;
      if (!offCtx) return;
      try { offCtx.drawImage(video, 0, 0, off.width, off.height);
      } catch (err) {
        usingChroma = false; fgCanvas.style.display = 'none'; fgVideo.style.display = 'block';
        fgVideo.play().catch(()=>{ document.getElementById('playOverlay').style.display = 'flex'; });
        return;
      }
      let frame;
      try { frame = offCtx.getImageData(0,0,off.width,off.height);
      } catch (err) {
        usingChroma = false; fgCanvas.style.display = 'none'; fgVideo.style.display = 'block';
        fgVideo.play().catch(()=>{ document.getElementById('playOverlay').style.display = 'flex'; });
        return;
      }
      const settings = infoObj && infoObj.preset ?
      infoObj.preset : { threshold:0.4, diff:30, soft:30 };
      const keyColor = infoObj && infoObj.keyColor ? infoObj.keyColor : 'green';
      const processed = applyChromaKey(frame, settings, keyColor);
      offCtx.putImageData(processed, 0, 0);
      drawProcessedToScreen();
    }

    function startChromaIntervalIfNeeded(infoObj){
      const hints = getPerformanceHints();
      chromaFps = hints.processingScale >= 0.85 ? 30 : hints.processingScale >= 0.6 ? 20 : 12;
      stopChromaInterval();
      if (!usingChroma || visibilityPaused) return;
      chromaIntervalId = setInterval(()=>{ processFrame(fgVideo, infoObj); }, Math.round(1000 / chromaFps));
    }

    function stopChromaInterval(){
      if (chromaIntervalId) { clearInterval(chromaIntervalId); chromaIntervalId = null; }
    }

    function showContainer(){ fgContainer.style.display = 'flex'; fgContainer.classList.remove('exit'); fgContainer.classList.add('enter'); }
    function hideContainerInstantlyForTransition(){ fgContainer.classList.remove('enter'); fgContainer.classList.add('exit'); }

    function scheduleNextVideo(afterSeconds = 3, excludeId = null){
      if (scheduledTimer){ clearTimeout(scheduledTimer); scheduledTimer = null; }
      hideContainerInstantlyForTransition();
      scheduledTimer = setTimeout(()=>{ const next = pickRandomVideo(excludeId); if (!next) return; playVideoClip(next); }, afterSeconds*1000);
    }

    const fireCanvas = document.createElement('canvas');
    fireCanvas.className = 'firework-canvas';
    fireCanvas.style.position = 'absolute';
    fireCanvas.style.left = '0';
    fireCanvas.style.top = '0';
    fireCanvas.style.width = '100%';
    fireCanvas.style.height = '100%';
    fireCanvas.style.zIndex = '9999';
    fireCanvas.style.pointerEvents = 'none';
    if (fgContainer) fgContainer.appendChild(fireCanvas);
    const fctx = fireCanvas.getContext ? fireCanvas.getContext('2d') : null;

    function resizeFireCanvas(){
      const rect = fgContainer.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (fireCanvas.width !== w || fireCanvas.height !== h) {
        fireCanvas.width = w;
        fireCanvas.height = h;
        fireCanvas.style.width = rect.width + 'px';
        fireCanvas.style.height = rect.height + 'px';
        fctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }
    window.addEventListener('resize', resizeFireCanvas, {passive:true});
    setTimeout(resizeFireCanvas, 120);
    function explodeParticlesAt(x, y, colors, count = 60, duration = 650) {
      const hints = getPerformanceHints();
      const rect = fgContainer.getBoundingClientRect();
      const areaFactor = Math.min(2.2, Math.max(0.45, (rect.width * rect.height) / (360 * 640)));
      let effectiveCount = Math.round(count * areaFactor);
      if (hints.processingScale < 0.45) effectiveCount = Math.max(12, Math.round(effectiveCount * 0.30));
      else if (hints.processingScale < 0.6) effectiveCount = Math.max(18, Math.round(effectiveCount * 0.45));
      else if (hints.processingScale < 0.85) effectiveCount = Math.max(28, Math.round(effectiveCount * 0.7));
      effectiveCount = Math.min(220, effectiveCount);
      const targetFps = hints.processingScale >= 0.85 ? 50 : hints.processingScale >= 0.6 ? 36 : 24;
      const frameInterval = 1000 / targetFps;

      const particles = [];
      function rnd(min, max){ return Math.random()*(max-min)+min; }

      for (let i = 0; i < effectiveCount; i++) {
        const angle = rnd(0, Math.PI*2);
        const speed = rnd(1.2, 6.0);
        particles.push({
          x, y,
          vx: Math.cos(angle) * speed * rnd(0.6, 1.2),
          vy: Math.sin(angle) * speed * rnd(0.6, 1.2) - rnd(0.6, 2.2),
          life: rnd(duration*0.65, duration*1.05),
          age: 0,
          radius: rnd(1.6, 5.2),
          color: colors[Math.floor(Math.random()*colors.length)]
         });
      }

      const safeTimeoutMs = Math.round(duration + 400);
      const start = performance.now();

      return new Promise(resolve => {
        let lastFrameTime = 0;
        let finished = false;
        const safeTimer = setTimeout(() => {
          if (!finished) {
            finished = true;
            try { fctx.clearRect(0,0,fireCanvas.width,fireCanvas.height); } catch(e){}
            resolve();
           }
        }, safeTimeoutMs);

        function frame(now){
          try {
            if (finished) return;
            if (!lastFrameTime) lastFrameTime = now;
            const dt = now - lastFrameTime;
            if (dt < frameInterval) { requestAnimationFrame(frame); return; }
            lastFrameTime = now;

            const t = now - start;
            fctx.clearRect(0,0,fireCanvas.width,fireCanvas.height);

            for (let p of particles) {
              p.age = t;
              const lifeRatio = Math.max(0, 1 - p.age / p.life);
              p.x += p.vx * (dt/16.67);
              p.y += p.vy * (dt/16.67);
              p.vy += 0.16 * (dt/16.67);
              const alpha = Math.max(0, Math.min(1, lifeRatio));
              fctx.globalAlpha = alpha;
              fctx.beginPath();
              fctx.fillStyle = p.color;
              fctx.arc(p.x, p.y, p.radius * (0.6 + lifeRatio * 0.8), 0, Math.PI*2);
              fctx.fill();
              fctx.globalAlpha = Math.max(0, alpha * 0.22);
              fctx.beginPath();
              fctx.fillStyle = p.color;
              fctx.arc(p.x, p.y, (p.radius * 5) * (0.22 + (1 - lifeRatio) * 0.9), 0, Math.PI*2);
              fctx.fill();
            }

            fctx.globalAlpha = 1;
            if (t < duration) { requestAnimationFrame(frame); }
            else {
              finished = true;
              clearTimeout(safeTimer);
              try { fctx.clearRect(0,0,fireCanvas.width,fireCanvas.height); } catch(e){}
              resolve();
            }
          } catch (err) {
            finished = true;
            clearTimeout(safeTimer);
            try { fctx.clearRect(0,0,fireCanvas.width,fireCanvas.height); } catch(e){}
            resolve();
          }
        }
        try { requestAnimationFrame(frame);
        } 
        catch (err) {
          clearTimeout(safeTimer);
          try { fctx.clearRect(0,0,fireCanvas.width,fireCanvas.height); } catch(e){}
          resolve();
        }
      });
    }

    async function doFireworkThenHide(){
      if (isAnimatingExplosion) return;
      isAnimatingExplosion = true;
      try {
        await new Promise(r => setTimeout(r, 8));
        try { fgVideo.pause(); } catch(e){}
        const rect = fgContainer.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        resizeFireCanvas();
        const palette = ['#ffcc00','#ff4d4d','#ffd700','#00fff7','#ff6ad5','#ff7f50','#8b5cf6'];
        fgContainer.style.transition = 'transform .25s ease-out, opacity .25s ease';
        fgContainer.style.transform = 'scale(0.96)';
        fgContainer.style.opacity = '0.85';
        await explodeParticlesAt(cx, cy, palette, 80, 700);
        fgContainer.style.opacity = '0';
        fgContainer.style.transform = 'scale(.8) translateY(10px)';
        await new Promise(r => setTimeout(r, 220));
        fgContainer.style.display = 'none';
        fgContainer.style.transform = '';
        fgContainer.style.opacity = '';
      } catch (err) {
        console.warn('doFireworkThenHide error:', err);
      } finally {
        isAnimatingExplosion = false;
      }
    }

    async function playVideoClip(infoObj){
      if (!infoObj) return;
      currentVideoObj = infoObj;
      usingChroma = true;
      if (lastObjectUrl) { try { URL.revokeObjectURL(lastObjectUrl); } catch(e){}; lastObjectUrl = null; }
      fgVideo.src = infoObj.src;
      fgVideo.load();
      const onMeta = () => {
        fgVideo.removeEventListener('loadedmetadata', onMeta);
        if (infoObj.id === 'hola') { fgContainer.style.bottom = '0px'; }
        else { fgContainer.style.bottom = '20px'; }
        placeRandomSide(infoObj);
        adjustContainerToVideo(fgVideo, infoObj);
        fgCanvas.style.display = 'block';
        fgVideo.style.display = 'none';
        fgVideo.play().catch(()=>{});
        bgVideo.play().catch(()=>{});
        startChromaIntervalIfNeeded(infoObj);
        showContainer();
      };
      fgVideo.addEventListener('loadedmetadata', onMeta);
      fgVideo.onerror = (e) => {
        usingChroma = false;
        fgCanvas.style.display = 'none';
        fgVideo.style.display = 'block';
        fgVideo.play().catch(()=>{ document.getElementById('playOverlay').style.display = 'flex'; });
      };
      fgVideo.onended = () => {
        scheduleNextVideo(3, infoObj.id);
      };
    }

    fgContainer.addEventListener('click', async (ev) => {
      if (isAnimatingExplosion) return;
      if (scheduledTimer) { clearTimeout(scheduledTimer); scheduledTimer = null; }
      usingChroma = false;
      stopChromaInterval();
      try { await doFireworkThenHide(); } catch (err) {}
      const currentId = currentVideoObj ? currentVideoObj.id : null;
      const next = pickRandomVideo(currentId);
      setTimeout(() => { playVideoClip(next); }, 420);
    });
    document.getElementById('playBtn').addEventListener('click', ()=>{
      document.getElementById('playOverlay').style.display = 'none';
      bgVideo.play().catch(()=>{}); fgVideo.play().catch(()=>{});
      try { bgMusic.play().catch(()=>{}); } catch(e){}
      if (currentVideoObj) startChromaIntervalIfNeeded(currentVideoObj);
    });
    let resizeRaf = null;
    window.addEventListener('resize', ()=> {
      if (resizeRaf) return;
      resizeRaf = requestAnimationFrame(()=> {
        resizeFireCanvas();
        if (currentVideoObj && fgVideo.videoWidth && fgVideo.videoHeight) {
          adjustContainerToVideo(fgVideo, currentVideoObj);
        }
        resizeRaf = null;
      });
    }, {passive:true});
    document.addEventListener('visibilitychange', ()=> {
      if (document.hidden) {
        visibilityPaused = true;
        stopChromaInterval();
      } else {
        visibilityPaused = false;
        if (usingChroma && fgVideo && !chromaIntervalId) {
          startChromaIntervalIfNeeded(currentVideoObj);
        }
      }
    }, {passive:true});

    /* ----------------------------
       POPUP M√ìVIL PARA SELECTS (CON TOGGLE MEJORADO)
       ---------------------------- */
    (function mobileSelectPopups() {
      const mobileQ = () => window.matchMedia('(max-width:780px)').matches;
  
      const SELECT_IDS = ['genre-select','demographic-select','rating-select'];
      let activePopup = null;
      let outsideListener = null;
      let resizeListener = null;
      let scrollListener = null;

      function closePopup() {
        if (activePopup) {
          try { activePopup.remove(); } catch(e){}
          activePopup = null;
        }
        if (outsideListener) { document.removeEventListener('pointerdown', outsideListener, true); outsideListener = null; }
        if (resizeListener) { window.removeEventListener('resize', resizeListener); resizeListener = null; }
        if (scrollListener) { window.removeEventListener('scroll', scrollListener, true); scrollListener = null; }
      }

      function createPopupFor(selectEl) {
        // Usamos 'click' general, y prevenimos default para evitar conflictos de doble apertura
        selectEl.addEventListener('click', function onClick(e){
          if (!mobileQ()) return;
          e.preventDefault();
          e.stopPropagation();

          // L√ìGICA DE TOGGLE ACTUALIZADA:
          // Si el popup activo es ESTE MISMO, lo cerramos y listo.
          if (activePopup && activePopup.dataset.ownerId === selectEl.id) {
            closePopup();
            return;
          } 
          
          // Si hay otro abierto, la funci√≥n openPopupFor se encarga de cerrarlo antes.
          openPopupFor(selectEl);
        });
        
        // Mantener accesibilidad teclado
        selectEl.addEventListener('keydown', (e) => {
          if (!mobileQ()) return;
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            if (activePopup && activePopup.dataset.ownerId === selectEl.id) {
                closePopup();
             } else {
                openPopupFor(selectEl);
            }
          }
        });
      }

      function openPopupFor(selectEl) {
        closePopup(); // Asegura cerrar cualquier otro previo
        
        const rect = selectEl.getBoundingClientRect();
        const docEl = document.documentElement;
        const winW = Math.max(docEl.clientWidth || 0, window.innerWidth || 0);
        const winH = Math.max(docEl.clientHeight || 0, window.innerHeight || 0);

        const popup = document.createElement('div');
        popup.className = 'mobile-select-popup';
        popup.setAttribute('role','listbox');
        popup.setAttribute('aria-label', selectEl.getAttribute('aria-label') || 'Opciones');
        
        popup.dataset.ownerId = selectEl.id;
        const pad = 8;
        
        // ARREGLO PARA QUE NO SE VEAN GIGANTES: Altura y ancho controlados
        const maxHeight = window.matchMedia('(max-width:420px)').matches ? 120 : 160;
        popup.style.maxHeight = maxHeight + 'px';
        
        // Ancho limitado al ancho de la pantalla menos un margen, o el ancho del select
        const width = Math.min(rect.width, Math.max(120, winW - 24));
        popup.style.minWidth = Math.max(110, width) + 'px';
        // Importante: resetear width a auto para evitar estiramientos raros
        popup.style.width = 'auto';

        let top = rect.bottom + 6;
        const estimatedHeight = Math.min(maxHeight, (selectEl.options ? selectEl.options.length * 36 : maxHeight));
        if (top + estimatedHeight + pad > winH) {
          top = rect.top - estimatedHeight - 6;
          if (top < pad) top = pad;
        }
        popup.style.left = Math.max(pad, rect.left) + 'px';
        popup.style.top = Math.max(pad, top) + 'px';

        const opts = Array.from(selectEl.options);
        opts.forEach((opt, idx) => {
          const d = document.createElement('div');
          d.className = 'opt';
          d.setAttribute('role','option');
          d.setAttribute('data-value', opt.value || opt.text);
          d.setAttribute('tabindex','0');
          if (opt.selected) d.setAttribute('aria-selected','true');
          d.textContent = opt.textContent || opt.innerText || opt.value;

          d.addEventListener('click', (ev) => {
            ev.stopPropagation();
            try {
              selectEl.value = opt.value;
              Array.from(selectEl.options).forEach(o => o.selected = (o.value === opt.value));
              const evCh = new Event('change', { bubbles: true });
              selectEl.dispatchEvent(evCh);
             } catch(e){}
            closePopup();
             try { selectEl.focus(); } catch(e){}
          });
          
          d.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter' || ev.key === ' ') {
               ev.preventDefault();
              d.click();
            } else if (ev.key === 'ArrowDown') {
              ev.preventDefault();
              const next = d.nextElementSibling;
              if (next) next.focus();
            } else if (ev.key === 'ArrowUp') {
              ev.preventDefault();
              const prev = d.previousElementSibling;
              if (prev) prev.focus();
            } else if (ev.key === 'Escape') {
              closePopup();
              try { selectEl.focus(); } catch(e){}
            }
          });
          popup.appendChild(d);
        });

        document.body.appendChild(popup);
        activePopup = popup;
        const selected = popup.querySelector('.opt[aria-selected="true"]') || popup.querySelector('.opt');
        if (selected) { selected.focus(); popup.scrollTop = Math.max(0, selected.offsetTop - 8); }

        outsideListener = function outsideHandler(ev){
          if (!activePopup) return;
          // Si el clic es en el select, el listener del select se encarga del toggle.
          // Aqu√≠ solo cerramos si el clic es FUERA del popup y FUERA del select.
          if (ev.target === selectEl || activePopup.contains(ev.target)) return;
          closePopup();
        };
        document.addEventListener('pointerdown', outsideListener, true);
        resizeListener = () => closePopup();
        window.addEventListener('resize', resizeListener);
        scrollListener = function scrollHandler(ev) {
          if (!activePopup) return;
          if (activePopup.contains(ev.target) || ev.target === selectEl) { return; }
          closePopup();
        };
        window.addEventListener('scroll', scrollListener, true);
      }

      function init() {
          try {
          SELECT_IDS.forEach(id => {
            const el = document.getElementById(id);
            if(el) createPopupFor(el);
          });
        } catch(e) {}
      }

      window.addEventListener('resize', function(){
        if (!mobileQ()) closePopup();
      }, { passive:true });
      if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
      else init();
      window._closeMobileSelectPopup = closePopup;
    })();

    function init(){
      fgContainer.style.display = 'none';
      fgCanvas.style.display = 'none'; fgVideo.style.display = 'none';
      const first = pickRandomVideo(null);
      if (!first) return;
      playVideoClip(first);
    }

    init();
    window.addEventListener('beforeunload', ()=>{ if (lastObjectUrl) try{ URL.revokeObjectURL(lastObjectUrl); } catch(e){}; });

  </script>
</body>
</html>